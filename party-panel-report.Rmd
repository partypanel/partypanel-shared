---
title: "Party Panel `r params$waveNumber` Report"
author: "Gjalt-Jorn Peters (Greater Good, Open Universiteit & Academy of Behavior Change) & Judith Noijen (Jellinek Preventie)"
date: "`r format(Sys.time(), '%d %b %Y at %H:%M:%S');`"
output:
  html_document:
    toc: false
    css: "party panel reports.css"
params:
  #waveNumber: 15.1
  #waveNumber: 16.1
  #waveNumber: 17.1
  waveNumber: 18.1
  #basePath: 'B:/Data/research/party panel/partypanel-15.1'
  #basePath: 'B:/Data/research/party panel/partypanel-16.1'
  #basePath: 'B:/Data/research/party panel/partypanel-17.1'
  basePath: 'B:/Data/research/party panel/partypanel-18.1'
  sharedPath: 'B:/Data/research/party panel/partypanel-shared'
  #surveyId: 652829
  #surveyId: 321858
  #surveyId: 559363
  surveyId: 180103
  #startDate: '2015-06-28'
  #startDate: '2016-05-27'
  #startDate: '2017-04-20'
  startDate: '2018-07-04'
  #behaviors: ['highDose', 'strngXTC', 'testing']
  #behaviors: ['epc', 'epw', 'epb']
  behaviors: ['sibe', 'siba', 'sibd']
  categoricalQuestions: ['informedConsent', 'gender', 'hasJob', 'currentEducation', 'prevEducation', 'country']
editor_options: 
  chunk_output_type: console
---

```{r pp-parse-params, echo=FALSE}
waveNumber <- params$waveNumber;
basePath <- params$basePath;
sharedPath <- params$sharedPath;
surveyId <- params$surveyId;
startDateRaw <- as.POSIXct(params$startDate);
startDate <- format(startDateRaw, format="%d %B %Y");
embargoLiftedDate <- startDateRaw + lubridate::years(2);
embargoLiftedDate <- format(embargoLiftedDate, format="%d %B %Y");
behaviors <- params$behaviors;
categoricalQuestions <- params$categoricalQuestions;
```

```{r general-preparation, echo=FALSE, warning=FALSE, message=FALSE}

#source("B:/Data/statistics/R/library/update-UFS.R");
require('userfriendlyscience', quietly=TRUE);
safeRequire('ufs');          ### New userfriendlyscience
safeRequire('behaviorchange');  ### For determinant study analyses
safeRequire('grid');         ### To manipulate graphics
safeRequire('gridExtra');    ### To manipulate graphics
safeRequire('ggplot2');      ### To draw and edit plots
safeRequire('ggrepel');      ### To avoid overlapping text labels
safeRequire('ggridges');     ### For Ridgeline plots
safeRequire('DiagrammeR');   ### For the determinant structures
safeRequire('data.tree');    ### For the 'plot.Node'
safeRequire('knitr');        ### To knit the Rmarkdown
safeRequire('plyr');         ### For data manipulation
safeRequire('dplyr');        ### Also for data manipulation (case_when)
safeRequire('car');          ### For Recode
safeRequire('digest');       ### To make MD5 hashes
safeRequire('pander');       ### For pretty R Markdown object printing
safeRequire('xtable');       ### For pretty tables in R Markdown
safeRequire('lubridate');    ### For extracting hours from datetimes
safeRequire('tools');        ### For 'toTitleCase' function
safeRequire('webshot');      ### For screenshotting htmlWidgets (diagrams)
safeRequire('summarytools'); ### For an overview of the dataset
safeRequire('ggmap');        ### For mapping data to the map of the Netherlands

###########################################################################
### Party Panel settings
###########################################################################

maxIncorrectClassAnswers <- 5;
thresholdForExceptionalAnswer <- .025;
thresholdForExceptionalCase <- .01;

###########################################################################
### Configure RMarkdown etc
###########################################################################

maxFigWidth = 20 / 2.54;
defaultFigWidth = 12 / 2.54;
maxFigHeight = 29 / 2.54;
defaultFigHeight = 12 / 2.54;

options(width=160);
options(scipen=100);
#options(xtable.type = "html");

panderOptions('knitr.auto.asis', FALSE);
panderOptions('table.split.table', Inf);

knitr::opts_chunk$set(echo=FALSE);
knitr::opts_chunk$set(comment=NA);
knitr::opts_chunk$set(cache=FALSE);
knitr::opts_chunk$set(dev="png",
		  		            dev.args=list(type="cairo"),
			    	          dpi=100);
knitr::opts_chunk$set(fig.width=defaultFigWidth);
knitr::opts_chunk$set(fig.height=defaultFigHeight);

options(ufs.knitFig.figWidth = defaultFigWidth);
options(ufs.knitFig.figHeight = defaultFigHeight);

setFigCapNumbering();
setTabCapNumbering();

###########################################################################
### Set paths and filenames
###########################################################################

### Set derived paths
scriptPath <- file.path(basePath, 'results - analysis scripts');
workingPath <- file.path(basePath, 'results - intermediate output');
dataPath <- file.path(basePath, 'results - data');

### Set filenames
dataFileRegEx <- paste0('survey_', surveyId, '_R_data_file.*\\.csv');
dataLoadScriptName <- paste0('survey_', surveyId, '_R_syntax_file.R');

###########################################################################
### Load resources
###########################################################################

ppLogoAsSVG <- paste0(readLines(file.path(sharedPath,
                                          "pp_pp-logo.html")),
                      collapse="");

###########################################################################
### Set variables & helper functions
###########################################################################

weekDays <-  c("Monday", "Tuesday", "Wednesday", "Thursday",
               "Friday", "Saturday", "Sunday");

### Load spatial data for postcodes
pcDat <- data.frame(postcode =  c(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99),
                    lat = c(52.3678024669572, 52.3455635724132, 52.2501138713815, 52.3585841561271, 52.3735313335077, 52.4657234141959, 52.6830233696612, 52.8198812701222, 52.639550621648, 52.4950689582663, 52.3856186275876, 52.2953703699729, 52.1292546069181, 52.161384292839, 52.1219310706044, 52.0684520747327, 52.0033402777623, 52.0563875683333, 52.0012138989129, 51.8986006453915, 51.9193874565932, 51.9106309680917, 51.8140252861272, 51.8149115339002, 52.0425276819077, 52.0934177824935, 52.1735550175486, 52.1523629740434, 52.223637595618, 52.0279361091616, 51.9054273863578, 51.915733212362, 51.8214914178629, 51.543768240357, 51.4892107569007, 51.3084062814104, 51.5147702745308, 51.5716616062968, 51.5747515937066, 51.6667015879655, 51.5549425996685, 51.6281052353666, 51.6782564610835, 51.7656968848253, 51.6366014520531, 51.3773177941176, 51.4597694831659, 51.4561668812027, 51.5657913844856, 51.3673618493396, 51.2198301363131, 51.0044676214146, 50.8399895742703, 50.8892820844185, 50.8949574101474, 51.8139166230324, 51.8719970570536, 52.0258947138041, 51.9758504258543, 51.9808607088139, 51.9332441744435, 52.0118296962591, 52.1317418255387, 52.2066433697708, 52.2679816480253, 52.2558617315003, 52.3814194800148, 52.5961180135375, 52.7757597738851, 52.7160955644958, 52.4859065597251, 52.3693689406752, 52.5307269978189, 52.747461266424, 52.9652050745035, 52.9094416896853, 53.026376169836, 53.0313126432087, 53.2061363841068, 53.2017360846828, 53.2012055919669, 53.3555306903419, 53.166322821535, 53.1329669620421, 52.9877145107302, 52.9592909500932, 53.1332498567166, 53.2160520411166, 53.2440706462868, 53.3389037688135),
                    lon = c(4.88265296235255, 4.92048844018191, 5.20016981451878, 5.19692084970926, 4.96119798514817, 4.80566389502282, 5.11709329957045, 4.82220173575481, 4.73944411275498, 4.65711588941856, 4.63162288403011, 4.61303752028347, 4.3931852765124, 4.51168737011436, 4.63123989742888, 4.29372836005594, 4.33979586949051, 4.54021535596711, 4.73452186458328, 4.61368753801164, 4.49164782911762, 4.33928060878812, 4.2829687516736, 4.69600707584607, 4.99433000213242, 5.1095360206426, 4.97767698785868, 5.32054575304636, 5.48553597975019, 5.38238247299173, 5.45767067590559, 5.18795319713936, 4.97922665393621, 3.66936390672942, 3.90470966273241, 3.79097509053622, 4.27097697088173, 4.50517380658332, 4.74318639278844, 4.84195733671919, 5.09638240155648, 5.00860229089637, 5.30772679514586, 5.46688460609673, 5.63639617277517, 5.38279769544641, 5.47322994631042, 5.70431204157048, 5.9899379118757, 6.10424312097242, 5.85259175752854, 5.83577253884675, 5.74094339560624, 5.93323298584949, 5.97735784656114, 5.86784740403142, 5.74067359988713, 5.66032248729721, 5.89735875172907, 6.07948324211148, 6.33285411615927, 6.63091103024003, 6.31125395599666, 5.99205974571486, 6.40504947547195, 6.88122082304407, 6.67828479011708, 6.54877480129994, 6.90784259899023, 6.35342435589724, 6.01919757591485, 6.13112521172761, 5.68385478833178, 5.90341298721153, 6.0379057614734, 5.70428744074426, 5.65270524920928, 5.48206467307413, 5.45632660753506, 5.80358549811831, 5.74644474592641, 5.95945766858073, 6.08416956383472, 6.39046332177174, 6.58818166864684, 6.97818596118079, 6.91595201151317, 6.57429045577232, 6.33816563415263, 6.72160735648967));

ggSave <- function(filename=default_name(plot), plot = last_plot(),
                   device="png", height=defaultFigHeight, width=defaultFigWidth, units="in",
                   dpi = 300, type="cairo-png", bg="transparent", ...) {
  ggsave(filename=filename, plot=plot, device=device,
         height=height, width=width, units=units,
         dpi=dpi, type=type, bg = bg, ...);
}

theme_pp <- function() {
  return (theme_bw());
}

### For recoding frequencies
defaultfrequencyCategories <-
  paste0("0='Not at all'; 1:2='1-2 times'; 3:4='3-4 times'; 5:7='Every month'; ",
         "8:20='Every few weeks'; 21:39='Every week'; ",
         "40:65='Twice a week'; 66:Inf='More often'");
defaultfrequencyCategories_nl <-
  paste0("0='Niet'; 1:2='1-2 keer'; 3:4='3-4 keer'; 5:7='Maandelijks'; ",
         "8:20='Elke paar weken'; 21:39='Elke week'; ",
         "40:65='Twee keer per week'; 66:Inf='Vaker'");

### Get RColorBrewer palette Set1
# cat0("c(", vecTxtQ(brewer.pal(9, 'Set1'), lastElements=0), ")");
palette_pp <- c('#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00',
                '#FFFF33', '#A65628', '#F781BF', '#999999');

pp_knitFig_determinantTemplate <- paste0("\n\n```{r {{chunkName}}, fig.height={{figHeight}}, fig.width={{figWidth}}, fig.cap='{{figCaption}}', echo=FALSE, cache=FALSE, results='asis'}
  cat('\n\n');
  pandoc.p('');
  cat('\n\n');
  cat('<h{{headerLevel}}>{{headerName}}</h{{headerLevel}}>');
  cat('\n\n');
  cat(paste0('\n\nThese are the results for question ",
             "(or rather, variable) \"{{headerName}}\".\n\n'));",
  "
  cat('\n\n');
  if ({{drawPlot}}) {
    grid.newpage();
    grid.draw({{plotToDraw}});
  }
  cat('\n\n');
  pandoc.p('');
  cat('\n\n');
```\n\n");

pp_knitFig_determinantTemplate_sampleSize <- paste0("\n\n```{r {{chunkName}}, fig.height={{figHeight}}, fig.width={{figWidth}}, fig.cap='{{figCaption}}', echo=FALSE, cache=FALSE, results='asis'}
  cat('\n\n');
  pandoc.p('');
  cat('\n\n');
  cat('<h{{headerLevel}}>{{headerName}}</h{{headerLevel}}>');
  cat('\n\n');
  cat0('\n\nThese are the results for question (or rather, variable) \"{{headerName}}\" ({{sampleSize}} participants provided data).\n\n');
  cat('\n\n');
  if ({{drawPlot}}) {
    grid.newpage();
    grid.draw({{plotToDraw}});
  }
  cat('\n\n');
  pandoc.p('');
  cat('\n\n');
```\n\n");

### For printing single question easy bars
singleQuestionEasyBar <- function(item,
                                  data = dat,
                                  labelDataframe = labelDf,
                                  outputPath = workingPath,
                                  knitFig = TRUE,
                                  figWidth = 12,
                                  figHeight = 3,
                                  headerLevel=5,
                                  niceHeader=NULL) {
  
  if (item %in% labelDf$varNames.cln) {
    questionText <- labelDataframe[labelDf$varNames.cln==item, 'questionText'];
    question <- labelDataframe[labelDf$varNames.cln==item, 'subQuestions'];
    leftAnchor <- labelDataframe[labelDf$varNames.cln==item, 'leftAnchors'];
    rightAnchor <- labelDataframe[labelDf$varNames.cln==item, 'rightAnchors'];
  } else {
    questionText <- leftAnchor <- rightAnchor <- "";
    question <- item;
  }

  if (knitFig) {
    if (is.null(niceHeader)) {
      niceHeader <- item;
    }
    pandoc.header(niceHeader, level=headerLevel);
    cat("\n\n");
    cat(paste0("These are the results for question (or rather, variable) '<str>", item, "</str>'."));
    cat("\n\n");
  }
  
  if ((item %in% labelDf$varNames.cln) && (nchar(trim(questionText)) > 0)) {
    cat("\n\n");
    cat(paste0("The lead-in for this question was \"<str>", questionText, "</str>\"."));
    cat("\n\n");
  }
  
  res <- ggEasyBar(data,
                   item,
                   xlab=NULL, ylab=NULL,
                   showInLegend="none", fontColor="white",
                   biAxisLabels=list(leftAnchors=leftAnchor,
                                     rightAnchors=rightAnchor)) +
             scale_y_continuous(breaks=seq(0, 100, 10)) +
             theme(legend.position="none",
                   text=element_text(size=22),
                   plot.background = element_rect(fill = "transparent",
                                                  color = NA),
                   panel.grid = element_blank(),
                   #axis.ticks.x = element_line(size=1),
                   #axis.ticks.length=unit(1, 'line'),
                   title = element_text(size=20)) +
           ggtitle(question);

  if (!is.null(outputPath)) {
    ggSave(plot=res,
           file.path(outputPath,
                     paste0(item, ".png")),
           width=figWidth,
           height=figHeight,
           bg = "transparent");
  }
  if (knitFig) {
    knitFig(res,
            figWidth=figWidth,
            figHeight=figHeight,
            figCaption = item);
  }
  invisible(res);
}

### For printing single question easy bars
multiQuestionEasyBar <- function(items,
                                 data = dat,
                                 labelDataframe = labelDf,
                                 outputPath = workingPath,
                                 knitFig = TRUE,
                                 figWidth = 12,
                                 figHeight = 1.5+1.5*length(items)) {

  questionText <- labelDataframe[labelDf$varNames.cln %in% items, 'questionText'];
  question <- labelDataframe[labelDf$varNames.cln %in% items, 'subQuestions'];
  leftAnchor <- labelDataframe[labelDf$varNames.cln %in% items, 'leftAnchors'];
  rightAnchor <- labelDataframe[labelDf$varNames.cln %in% items, 'rightAnchors'];
  
  if ((length(unique(leftAnchor)) == 1) && (length(unique(rightAnchor)) == 1)) {
    leftAnchor <- unique(leftAnchor);
    rightAnchor <- unique(rightAnchor);
  }
  
  if (length(unique(questionText)) == 1) {
    subQuestions <- question;
    question <- unique(questionText);
  }
  
  cat("\n\n");
  pandoc.p(paste0("These are the results for questions ", vecTxtQ(items), "."));
  cat("\n\n");
  
  if (length(unique(questionText)) == 1) {
    subQuestions <- question;
    question <- unique(questionText);
    cat("\n\n");
    pandoc.p(paste0("The lead-in for these questions was <str>", question, "</str>."));
    cat("\n\n");
  }
  
  res <- ggEasyBar(data,
                   item,
                   xlab=NULL, ylab=NULL,
                   showInLegend="none", fontColor="white",
                   biAxisLabels=list(leftAnchors=leftAnchor,
                                     rightAnchors=rightAnchor)) +
             scale_y_continuous(breaks=seq(0, 100, 10)) +
             theme(legend.position="none",
                   text=element_text(size=22),
                   plot.background = element_rect(fill = "transparent",
                                                  color = NA),
                   panel.grid = element_blank(),
                   #axis.ticks.x = element_line(size=1),
                   #axis.ticks.length=unit(1, 'line'),
                   title = element_text(size=20)) +
           ggtitle(question);

  if (!is.null(outputPath)) {
    ggSave(plot=res,
           file.path(outputPath,
                     paste0(item, ".png")),
           width=figWidth,
           height=figHeight,
           bg = "transparent");
  }
  if (knitFig) {
    knitFig(res,
            figWidth=figWidth,
            figHeight=figHeight,
            figCaption = item);
  }
  invisible(res);
}

```

```{r wave-specific-preparation, child=file.path(scriptPath, paste0("partypanel-", waveNumber, "-wave-specific-preparation.Rmd"))}
```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

<div class='ppLogo'>
`r ppLogoAsSVG`
</div>

Party Panel `r waveNumber` {.tabset}
====================================

<div class="authorInfo">`r rmarkdown::metadata$author`</div>
<div class="creationDateInfo">This report is generated on `r format(Sys.time(), '%d %b %Y at %H:%M:%S');`.</div>

## Background

### Introduction

Party Panel is a Dutch panel study where determinants and beliefs underlying health behaviors in the Dutch nightlife are mapped. This wave started on `r startDate`. `r waveSpecificDescription`

This document is the report of the Party Panel results. This is a living document and may be updated.

This document is in English, except the section with prevention recommendations, because it is written specifically for Dutch prevention professionals.

### Publication and distribution

#### Press releases

It is not allowed to publish Party Panel results in a press release. Only the Celebrate Safe project committee has the right to publish press releases containing Party Panel results, and then only after explicit approval from Greater Good. If you think doing a press release about a specific Party Panel result can be helpful as a prevention effort, you can always contact the Celebrate Safe project committee and explain this to them. However, Party Panel is intended as scientific research and to inform prevention efforts: not as a marketing tool.

#### License governing sharing

Party Panel is primarily a scientific and prevention endeavour. We publish this report, the Party Panel data and resources, and the outcomes, usually after an embargo period, under the Creative Commons attribution share alike license (CC-BY-NC-SA; see http://creativecommons.org/licenses/by-nc-sa/4.0/). This means that you are allowed to copy and distribute these files freely, but you're not allowed to sell them. It also means that if you create derivative works (i.e. if you remix, transform, or build upon the material), you must distribute your contributions under the same license as the original.

#### Confidentiality and embargo

`r waveSpecificConfidentiality`

#### Full disclosure

Party Panel follows the Open Science principle of Full Disclosure. Each Party Panel wave has a component repository in the general Party Panel Open Science Framework repository at https://osf.io/s4fmu/. Note that the general terms and conditions as contained in the Creative Commons license listed above, as well as the restriction pertaining to press releases, remains in effect.

### Behavior Change

Party Panel was designed to inform development of effective behavior change interventions in the Dutch nightlife, to support a healthy, safe, fun nightlife where the personal integrity of its visitors is respected.

Reading this report may require expertise regarding behavior change. Interested readers who as yet lack the required knowledge can use the Open Access (freely available) articles about behavior change that are available at https://effectivebehaviorchange.com.

### Ethics

Ethical approval for the Party Panel determinant studies was granted by the committee for Ethical Testing of Research (commissie Ethische Toetsing Onderzoek, cETO) of the Open University of the Netherlands, under files numbers U2015/03757/HVM and U2017/03081/FRO. The applications and approval letters are available at the Open Science Framework repository for the shared Party Panel resources at https://osf.io/7bv4w/.

### Acknowledgements

Party Panel is the result of the combination of energy, knowledge, skills and enthusiasm of a large group of people. Party Panel is funded by Celebrate Safe, with a subsidy from the Dutch Ministry of Health, Welfare and Sport. It is developed, executed, analysed and managed by Greater Good, with invaluable input from Jellinek Preventie. Without the Unity peers' unique insights, the questionnaires and collected data would never reach the richness and depth it does. The Celebrate Safe project committee, advisory board, and affiliated expert organisations also provided valuable feedback. Without the festival and event organisers, clubs, and other nightlife organisations, we would never have been able to reach all the participants that we did. `r waveSpecificThankYous ` So thank you all!!! We hope you can benefit from these results as well, and in general, that they contribute to improving our nightlife.

### How to use this report

Because this report contains a lot of information, it is organised using tabs, which you see above this section. Click a tab to view the associated contents.

------

```{r load-data}

###########################################################################
### Load Party Panel data and extract labels
###########################################################################

### Note, this section also includes all commands that have to immediately
### follow the data loading, because they use the dataframe with the labels
### as generated by importLimeSurveyData

dat <- dat.raw <-
  importLimeSurveyData(dataPath = dataPath,
                       datafileRegEx = dataFileRegEx,
                       scriptfile = file.path(dataPath,
                                              dataLoadScriptName),
                       categoricalQuestions = categoricalQuestions,
                       encoding="UTF-8");

###########################################################################
### Prepare Party Panel data for verifying and preprocessing
###########################################################################

### Create a set of regular expressions to add underscores behind the behaviors
varnameRegExPairs <- lapply(behaviors, function(curBehav) {
  return(c(paste0("^", curBehav, "(.+)"),
           paste0(curBehav, "_\\1")));
});

if (exists('waveSpecificVarnameRegExPairs') && !is.null(waveSpecificVarnameRegExPairs)) {
  varnameRegExPairs <- c(varnameRegExPairs,
                         waveSpecificVarnameRegExPairs);
}

### Process the variables labels (subquestions, anchors etc)
labelDf <- processLSvarLabels(dat,
                              varnameRegExPairs = varnameRegExPairs,
                              leftAnchorRegExPairs = list(c(".*[[:graph:]]([A-Z][a-z][^|]*)\\|(.+)",
                                                            "\\1"),
                                                          c(".*\\.\\.\\.([^|]+)\\|(.+)",
                                                            "\\1")),
                              rightAnchorRegExPairs = list(c(".*[[:graph:]]([A-Z][a-z][^|]*)\\|(.+)",
                                                             "\\2"),
                                                           c(".*\\.\\.\\.([^|]+)\\|(.+)",
                                                             "\\2")));

### Replace variable names with the versions with the
### inserted underscores
names(dat) <- labelDf$varNames.cln;

###########################################################################
### Prepare data structure for later pre-analyses and analyses
###########################################################################

### Get group names
groupNames <- gsub('Groep\\.tijd\\.\\.', '',
                   grep('Groep\\.tijd\\.\\.', names(dat), value=TRUE));

### Remove questions that only have missing values
varNames.onlyMissingValues <-
  names(dat)[nrow(dat) == lapply(dat, function(x) sum(is.na(x)))];
dat <- dat[, !(names(dat) %in% varNames.onlyMissingValues)];

```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

## Prevention recommendations

This section contains recommendations for prevention professionals. Because these recommendations are for prevention professionals working with nightlife-related behaviors in the Netherlands, these recommendations will be in Dutch.

### Inleiding

Party Panel is een semi-panel studie in het Nederlandse uitgaansleven met als doel de determinanten van verschillende uitgaansleven-gerelateerde gezondheidsgedragingen in kaart te brengen. Het in kaart brengen van die determinanten is nodig voor preventie: je kunt geen effectieve interventie ontwikkelen als je niet weet waar die interventie zich op moet richten.

Preventie betreft altijd een poging om iets te voorkomen (letterlijk per definitie), en bijna altijd een poging om iets onwenselijks te voorkomen. De te voorkomen zaken zijn altijd het gevolg van menselijk gedrag (van bezoekers van een feest of optreden, van clubeigenaren, van politici, en ga  maar door), en de oorzaken van menselijk gedrag zijn in te delen in twee categorieën: de omgeving en de menselijke psychologie. Effectieve preventie vereist noodzakelijkerwijs eerst inzicht in die oorzaken. Pas als je dat inzicht hebt kun je bepalen of je probeert om de omgeving te veranderen (bijvoorbeeld gratis condooms, oordopjes, of water verstrekken; dit bereik je door gedrag van beslissers in de omgeving, zoals politici of organisatoren, te veranderen) of om de menselijke psychologie te veranderen (bijvoorbeeld door misverstanden de wereld uit te helpen of door mensen tips te geven om zich aan hun voornemen te houden).

Als je incidenten in het uitgaansleven wil voorkomen, en eigenlijk in het algemeen gewoon een leuk en veilig uitgaansleven wil, dan moet je dus eerst weten waarom mensen doen wat ze doen. Party Panel is een instrument om dit in kaart te brengen.

### Verandering van gedrag

Gedragsverandering is eigenlijk gewoon versneld leren. Mensen kunnen 'van nature' natuurlijk al goed leren: wezens zonder het vermogen om te leren hebben een veel lagere overlevingskans, waardoor het vermogen te leren in veruit de meeste diersoorten is geëvolueerd. Tegelijkertijd is dat vermogen om te leren natuurlijk nooit ontwikkeld om preventie mogelijk te maken. Kortom: als je mensen wil helpen hun gedrag te veranderen, gebruik je een proces (leren) dat eigenlijk ergens anders voor is ontwikkeld.

Het komt daarom erg nauw wat je doet: het is moeilijk om precies het 'leerproces' waar de menselijke psychologie mee is uitgerust na te bootsen om zo de juiste veranderingen in iemands opvattingen te bewerkstelligen. Omdat dit zo lastig is, is er veel onderzoek naar gedaan. Uit dat onderzoek zijn inmiddels een aantal methoden voor gedragsverandering bekend. Deze methoden maken gebruik van verschillende vormen van leren, die soms op verschillende typen geheugen zijn gericht.

Methoden voor gedragsverandering zijn niet zomaar 'blind' te gebruiken: het is jammer genoeg niet zo dat je alleen maar het “juiste truckje” hoeft te vinden. Verschillende methoden zijn in staat om verschillende soorten opvattingen te veranderen. Mensen kunnen immers allerlei uiteenlopende redenen hebben voor hun gedrag, en die vereisen allemaal een andere aanpak. Voordat je echt over verandering na kunt denken, moet je dus begrijpen waarom mensen doen wat ze doen.

### Verklaring van gedrag

Mensen kunnen allerlei redenen hebben voor wat ze doen. Menselijk gedrag is complex: denk maar eens na over waarom je hier nu bent; waarom je gisteren hebt gegeten wat je hebt gegeten; waarom je vorig weekend hebt besteed zoals je dat deed; en ga maar door. Voor een gegeven gedrag (bijvoorbeeld in een restaurant pizza of pasta bestellen) kunnen, als je maar genoeg mensen vraagt, honderden, soms duizenden redenen zijn. Dat maakt het natuurlijk lastig om in kaart te brengen waarom mensen doen wat ze doen.

Gelukkig wordt er al een dikke honderd jaar onderzoek gedaan in de psychologie, dus inmiddels zijn hier allerlei oplossingen voor gevonden. In de basis zijn die gebaseerd op hetzelfde uitgangspunt: al die verschillende redenen kun je groeperen. Sommige redenen lijken namelijk nogal op elkaar. Mensen voelen bijvoorbeeld sociale druk; of houden rekening met hun lange-termijn doelen; of hebben niet het gevoel dat ze iets goed kunnen. Je kunt die honderden redenen dus ordenen door ze te groeperen, en dit is wat psychologische theorieën doen.

Er zijn inmiddels heel veel theorieën die verklaren waarom mensen doen wat ze doen. Veel gezondheidsgedrag is gedrag waar mensen over nadenken: zogenaamde beredeneerd gedrag. Een van de meest gebruikte theorieën over beredeneerd gedrag heet heel toepasselijk de "Beredeneerd Gedrag Benadering" (ok, hij heet eigenlijk de Reasoned Action Approach, RAA, wat toch wat beter klinkt). De RAA is de derde 'versie' van een theorie die hiervoor de Theory van Geplanned Gedrag heette, en daarvoor de Theorie van Beredeneerde Actie.

Deze theorie stelt dat beredeneerd gedrag vooral wordt bepaald door of mensen de intentie hebben om dat betreffende gedrag uit te voeren. Dat is natuurlijk nogal logisch: als je van plan bent om iets te doen, dan doe je het meestal ook, als er tenminste geen obstakels in de omgeving zijn, en als de controle over je gedrag niet afneemt. De kracht van de RAA zit in de voorspellers van die intentie. Dit zijn volgens de RAA drie groepen vergelijkbare redenen: attitude, waargenomen norm, en waargenomen gedragscontrole.

#### Attitude

Attitude is een soort 'gewogen gemiddelde' van alle voor- en nadelen van een gedrag, of accurater uitgedrukt, van de mogelijke gevolgen, hoe waarschijnlijk iemand denkt dat die gevolgen zijn, en hoe wenselijk iemand die gevolgen vindt. Inschatting van de risico’s van een gedrag maakt hier deel van uit, maar er is nog veel meer, bijvoorbeeld de voordelen van het gedrag (middelengebruik is bijvoorbeeld leuk/lekker).

Attitude bestaat dus uit twee onderdelen: de ingeschatte waarschijnlijkheid van de mogelijke gevolgen van gedrag, en de wenselijkheid van elk mogelijke gevolg (hoe wenselijk of onwenselijk iemand die gevolgen vindt).

#### Waargenomen norm

Waargenomen norm gaat over of je denkt dat de mensen die belangrijk voor je zijn het goed- of afkeuren als jij het betreffende gedrag uitvoert, en over of je denkt dat de mensen om je heen dat gedrag zelf uitvoeren. Of mensen iets goedkeuren of afkeuren, en wat ze zelf doen, hoeft natuurlijk niet hetzelfde te zijn: ouders kunnen best hun kinderen vertellen dat ze nooit moeten gaan roken, maar zelf wel roken.

Waargenomen norm bestaat uit drie onderdelen: je inschatting van goed- of afkeuring door anderen (injunctieve norm), de mate waarin je waarde hecht aan die oordelen (motivation to comply), en je inschatting van het gedrag van anderen (descriptieve norm).

#### Waargenomen gedragscontrole

Waargenomen gedragscontrole gaat over of je denkt dat je het gedrag uit kunt voeren: is het onder jouw controle, en heb je de nodige vaardigheden wel? Je kunt best van plan zijn om genoeg te rusten als je ecstasy hebt gebruikt, maar als er geen chill out is, wordt dat lastig. En wat als je hebt besloten om geen cocaine te gebruiken, maar de drie mensen waar je mee uit bent doen dat wel – weet je hoe je dan toch niet zwicht voor de verleiding?
Waargenomen gedragscontrole bestaat uit twee onderdelen: de hoeveelheid controle die je over gedrag hebt (controle), en hoe goed je denkt dat je in het gedrag bent (capaciteit).

### Party Panel en gedragsverandering

De RAA stelt dat als je de redenen in die drie categorieën goed in kaart brengt, dat je dan goed kunt voorspellen wat mensen doen. En als je dat kunt, begrijp je genoeg van het gedrag om te gaan denken aan gedragsverandering: dan kun je op zoek naar methoden die werken om de redenen die belangrijk zijn, te veranderen. In een plaatje ziet die RAA er zo uit:
 
Naast de RAA zijn er nog talloze andere theorieën om gedrag te verklaren. Deze groeperingen van gelijksoortige redenen heten in de psychologie variabelen, en als het gaat over gedragsverandering worden ze vaak determinanten genoemd.

Gedragsverandering is een subdomein van de psychologie. Naast grondige kennis van de psychologie vereist het constructief kunnen denken over effectieve gedragsveranderingsinterventies daarom specialistische kennis met betrekking tot de theorie van verklaring en verandering van gedrag. In de voorgaande alinea's is gepoogd om voldoende over te brengen zodat ook leken met betrekking tot gedragsverandering uit de voeten kunnen met dit rapport. Lezers die zich verder willen verdiepen adviseren we om de 'Open Access' (gratis toegankelijke) inleidende, en verdiepende, artikelen over gedragsverandering op https://effectivebehaviorchange.com te raadplegen. Verder is het altijd raadzaam om bij de ontwikkeling van alle preventie (of andere campagnes) die zijn gericht op gedragsverandering, of verandering van antecedenten van gedrag zoals bewustwording of kennis, experts in de gedragsverandering te raadplegen.

```{r wave-specific-recommendations, child=file.path(scriptPath, paste0("partypanel-", waveNumber, "-wave-specific-recommendations.Rmd"))}
```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

## Data integrity & cleaning {.tabset}

### Data preprocessing

```{r wave-specific-data-preprocessing, child=file.path(scriptPath, paste0("partypanel-", waveNumber, "-wave-specific-preprocessing.Rmd"))}
```

```{r general-data-preprocessing, results='asis', message=FALSE, warning=FALSE}

###########################################################################
### Verify (and correct) classes of variables
###########################################################################

classCorrectionOutput <- "";
classCorrectionRowNumbers <- data.frame();

if (exists('waveSpecificClassCheckRegexes') && !is.null(waveSpecificClassCheckRegexes)) {
  for (currentClassRegex in waveSpecificClassCheckRegexes) {
    tmpVarNames <- grep(currentClassRegex[1], names(dat), value=TRUE);
    for (currentVarName in tmpVarNames) {
      if (class(dat[, currentVarName]) != currentClassRegex[2]) {
        classCorrectionOutput <- paste0(classCorrectionOutput,
                                        "- Variable '", currentVarName,
                                        "' does not have the required/specified class '",
                                        currentClassRegex[2],
                                        "' but instead class '",
                                        class(dat[, currentVarName]),
                                        "'. Trying to convert.\n");
        newVarName <- paste0(currentVarName, "_preConversion");
        if (currentClassRegex[2] == 'numeric') {
          dat[, newVarName] <- dat[, currentVarName];
          dat[, currentVarName] <- convertToNumeric(dat[, currentVarName]);
        } else {
          ### Check whether function to convert to required class exists
          if (exists(paste0("as.", currentClassRegex[2]))) {
            dat[, newVarName] <- dat[, currentVarName];
            dat[, currentVarName] <- do.call(paste0("as.", currentClassRegex[2]),
                                             dat[, currentVarName]);
          } else {
            classCorrectionOutput <- paste0(classCorrectionOutput,
                                            "    - No function 'as.", currentClassRegex[2],
                                            "' exists, so I cannot convert.\n");
          }
        }
        if (!is.null(dat[, newVarName])) {
          inconsistencyIndices <- which((isTrue(dat[, newVarName] != dat[, currentVarName])) |
            isTrue((!is.na(dat[, newVarName])) & is.na(dat[, currentVarName])));
          ### Compare converted version to the original
          if (length(inconsistencyIndices) == 0 ) {
            classCorrectionOutput <- paste0(classCorrectionOutput,
                                            "    - Successfully converted, and all data points remained identical.\n\n");
          } else {
            misMatches <- dat[inconsistencyIndices, c(newVarName, currentVarName)];
            classCorrectionOutput <- paste0(classCorrectionOutput, 
                                            "    - Successfully converted, and found ", nrow(misMatches), " mismatches:\n\n");
            classCorrectionOutput <- paste0(classCorrectionOutput, paste0(sapply(1:nrow(misMatches),
                        function(i)
                          return(paste0("        - Row ", row.names(misMatches)[i], ": ", paste0(misMatches[i, ], collapse=" != "), "\n"))
                       ), collapse=""));
            classCorrectionOutput <- paste0(classCorrectionOutput, "\n");
            classCorrectionRowNumbers <- rbind.fill(classCorrectionRowNumbers,
                                                    data.frame(variable = rep(currentVarName, nrow(misMatches)),
                                                               rowNumber = row.names(misMatches)));
            rm(misMatches);
          }
        }
        rm(newVarName);
      } else {
        classCorrectionOutput <- paste0(classCorrectionOutput,
                                        "- Variable '", currentVarName,
                                        "' has the required/specified class '",
                                        currentClassRegex[2],
                                        "'.\n");
      }
    }
  }
}

###########################################################################
### Prepare data for analysis
###########################################################################

dataCleaningOutput <- "";

### Remove test entries
dataCleaningOutput <- c(dataCleaningOutput,
                        paste0(sum(isTrue(dat$testEntry_test, na=FALSE)),
                               " entries were test entries and were removed."));
dat <- dat[!isTrue(dat$testEntry_test, na=FALSE), ];

###########################################################################
### Age
###########################################################################

### Set 'age' to missing value where people did not want to provide their age
dataCleaningOutput <- c(dataCleaningOutput,
                        paste0(sum(isTrue(dat$age == 0)),
                               " participants responded that they did ",
                               "not want to provide their age (their ",
                               "age was set to NA)."));
dat$age <- ifelse(dat$age == 0, NA, dat$age);

###########################################################################
### Gender
###########################################################################

### Translate gender
dat$gender <- factor(as.numeric(dat$gender),
                     levels=1:4,
                     labels=c("Decline to answer",
                              "Male", "Female",
                              "Other (e.g. genderqueer, nonbinary)"));

### Set 'gender' to missing value where people did not want to provide their age
dataCleaningOutput <- c(dataCleaningOutput,
                        paste0(sum(isTrue(dat$gender == 'Decline to answer')),
                               " participants responded that they did ",
                               "not want to provide their gender (their ",
                               "gender was set to NA)."));
dat$gender[dat$gender == "Decline to answer"] <- NA;

###########################################################################
### Education level
###########################################################################

### Compute education level from education levels
dat$education <- ifelse(grepl("WO", dat$currentEducation),
                        'Highest',
                        ifelse(grepl("HBO", dat$currentEducation),
                               "High",
                               ifelse(grepl("ROC", dat$currentEducation),
                                      "Mid",
                                      ifelse(grepl("VWO", dat$currentEducation),
                                             "Highest",
                                             ifelse(grepl("HAVO", dat$currentEducation),
                                                    "High",
                                                    ifelse(grepl("VMBO", dat$currentEducation),
                                                           "Mid",
                                                           NA))))));
dat$education <- ifelse(grepl("WO", dat$prevEducation),
                        'Highest',
                        ifelse(grepl("HBO", dat$prevEducation),
                               'High',
                               ifelse(grepl("ROC", dat$prevEducation),
                                      'Mid',
                                      ifelse(grepl("VWO", dat$prevEducation),
                                             'Mid',
                                             ifelse(grepl("HAVO", dat$prevEducation),
                                                    'Mid',
                                                    ifelse(grepl("VMBO", dat$prevEducation),
                                                           'Low',
                                                           ifelse(grepl("Basis", dat$prevEducation),
                                                                  'Lowest',
                                                                  dat$education)))))));
dat$education <- factor(dat$education, levels=c("Low", "Mid", "High", "Highest"),
                        ordered=TRUE, labels=c("Low (primary or VMBO)", "Mid (MBO, HAVO, VWO)",
                                               "High (HBO)", "Highest (WO)"));

###########################################################################
### Times and dates
###########################################################################

### Convert time variables to POSIXct
dat$startdate <- as.POSIXct(dat$startdate);
dat$submitdate <- as.POSIXct(dat$submitdate);
dat$startweekday <- factor(weekdays(dat$startdate), levels=weekDays);
dat$submitweekday <- factor(weekdays(dat$submitdate), levels=weekDays);
dat$starthour <- factor(hour(dat$startdate));
dat$submithour <- factor(hour(dat$submitdate));
dat$startday <- wday(dat$startdate);
dat$submitday <- wday(dat$submitdate);

###############################################################################
### Make bidimensional scales bidimensional
###############################################################################

if (exists('waveSpecificBidimensionalScales') &&
    !is.null(waveSpecificBidimensionalScales)) {
  for (i in seq_along(waveSpecificBidimensionalScales)) {

    dat[, grep(waveSpecificBidimensionalScales[[i]][1],
               names(dat), value=TRUE)] <-
      dat[, grep(waveSpecificBidimensionalScales[[i]][1],
               names(dat), value=TRUE)] +
        as.numeric(waveSpecificBidimensionalScales[[i]][2]);
  }
}

###############################################################################
### Process frequency variables (they consist of two answers each)
###############################################################################

frequencyVarNames <- list();
frequencyCategoryVarNames <- list();

for (currentFrequencyVar in frequencyVars) {
  frequencyVarNames[[currentFrequencyVar]] <- vector();
  currentRegEx <- paste0(currentFrequencyVar, "Period_([^_]*)$");
  specifiers <- gsub(currentRegEx, "\\1",
                     grep(currentRegEx, names(dat), value=TRUE));
  if (length(specifiers) == 0) {
    warning("For frequencyVar '", currentFrequencyVar, "', I could ",
            "find no matches when trying to compute the multiplication!");
  } else {
    dat <- cbind(dat, as.data.frame(lapply(specifiers, function(x) {
      ### Add final variable name to the list of vectors for easy access in analyses
      frequencyVarNames[[currentFrequencyVar]] <<-
        c(frequencyVarNames[[currentFrequencyVar]], paste0(currentFrequencyVar, "_", x));
      ### Compute product and store it in the dataframe
      return(structure(list(dat[, paste0(currentFrequencyVar, "Period_", x)] *
                            dat[, paste0(currentFrequencyVar, "Nr_", x, "_nr")]),
                       names=paste0(currentFrequencyVar, "_", x)));
    })));
    dat <- cbind(dat, as.data.frame(lapply(specifiers, function(x) {
      ### Add variable name of categorized variable to the dataframe
      frequencyCategoryVarNames[[currentFrequencyVar]] <<-
        c(frequencyCategoryVarNames[[currentFrequencyVar]], paste0(currentFrequencyVar, "_cat_", x));
      ### Compute product and store it in the dataframe
      return(structure(list(car::Recode(dat[, paste0(currentFrequencyVar, "_", x)],
                                        as.factor=TRUE,
                                        defaultfrequencyCategories,
                                        levels=gsub(".*'(.*)'.*",
                                                    "\\1",
                                                    unlist(strsplit(defaultfrequencyCategories, ';'))))),
                       names=paste0(currentFrequencyVar, "_cat_", x)));
    })));
  }
}

###############################################################################
### For each behavior, process the determinant structure to add variable
### names, compute products and scales, and add variable lables.
###############################################################################

for (currentDetStruct in detStruct) {
  ### Add variable names to the determinant structure object
  detStructAddVarNames(currentDetStruct,
                       names = grep("\\.\\.", names(dat), value=TRUE, invert=TRUE));
  ### Compute products
  dat <- detStructComputeProducts(currentDetStruct, dat=dat);
  ### Compute scales
  dat <- detStructComputeScales(currentDetStruct, dat);
  ### Add variable labels
  detStructAddVarLabels(currentDetStruct, labelDf);
}

###############################################################################
### Process scales & indices that were not in the determinant structures
###############################################################################

if (exists('waveSpecificScales') && !is.null(waveSpecificScales)) {
  dat <- makeScales(dat = dat,
                    scales = waveSpecificScales);
}

```

```{r data-integrity, results='asis', message=FALSE, warning=FALSE}

dat <- checkDataIntegrity(c(list(c('^age$', '<80')),
                            waveSpecificDataIntegrityChecks),
                          dat,
                          removeCases = FALSE,
                          replace=TRUE,
                          silent=TRUE,
                          rmarkdownOutput=TRUE);

### Extract log
checkDataIntegrityLog <- attr(dat, 'checkDataIntegrity_log');

checkDataIntegrityLog <- paste0("\n\n#### Data Integrity Checking Logs\n",
                                checkDataIntegrityLog);

### Append to full log
dataCleaningOutput <- c(dataCleaningOutput,
                        checkDataIntegrityLog);

### Remove test entries
removedTestEntries <- sum(isTrue(dat$testEntry_test, na=FALSE));
dat <- dat[!isTrue(dat$testEntry_test, na=FALSE), ];

###########################################################################
### Identify and remove cases with too many exceptional values; and set the
### remaining 1% of highest and 1% of lowest values to NA
###########################################################################

### Find exceptional scores
dat <- exceptionalScores(dat,
                         exception = thresholdForExceptionalAnswer);

### Now find who has an exceptional number of exceptional scores.
dat$exceptionalNrOfExceptionalScores <- exceptionalScores(dat$exceptionalScores,
                                                          append=FALSE,
                                                          exception=thresholdForExceptionalCase);

### Store threshold and number of deleted participants
exceptionalScoreRemovalThreshold <- min(dat$exceptionalScores[dat$exceptionalNrOfExceptionalScores==1]);
nrOfDeletedParticipants <- sum(dat$exceptionalNrOfExceptionalScores > 0);
rowNumbersOfDeletedParticipants <- cbind(which(dat$exceptionalNrOfExceptionalScores > 0),
                                         dat$exceptionalScores[dat$exceptionalNrOfExceptionalScores > 0]);

rowNumbersOfDeletedParticipants <- apply(rowNumbersOfDeletedParticipants, 1,
                                         function(x) {return(paste0(x[1], " (", x[2], ")"))});

### Actually remove them
dat <- dat[dat$exceptionalNrOfExceptionalScores == 0, ];

###########################################################################
### Remove cases with frequent answers not matching correct class
###########################################################################

rowsWithTooManyIncorrectClasses <-
  as.numeric(names(table(classCorrectionRowNumbers$rowNumber))[
    table(classCorrectionRowNumbers$rowNumber) > maxIncorrectClassAnswers]);

if (length(classCorrectionRowNumbers) > 0) {
  dat <- dat[-rowsWithTooManyIncorrectClasses, ];
}

```

Participants of `r removedTestEntries` entries indicated that they were test entries (e.g. for testing the survey, or when participants were not entirely serious about completing the survey).

Furthermore, `r nrOfDeletedParticipants;` participants were among the `r 100*thresholdForExceptionalCase`% with `r exceptionalScoreRemovalThreshold` or more exceptional answers (in the lowest `r 100*thresholdForExceptionalAnswer`% or the highest `r 100*thresholdForExceptionalAnswer`%), and were therefore removed from the dataset as well (row numbers (and number of exceptional anwers): `r vecTxt(rowNumbersOfDeletedParticipants);`).

`r length(rowsWithTooManyIncorrectClasses);` participants (rows `r vecTxt(rowsWithTooManyIncorrectClasses);`) had more than `r maxIncorrectClassAnswers;` answers that fell into the wrong class (e.g. typing letters where numbers were required) and were also removed.

### Summary of dataset

```{r summarytools-overview, results="asis", message=FALSE, warning=FALSE}
dfSummary(dat, plain.ascii = FALSE, style = "grid");
```

## Recruitment

```{r recruitment-info, message=FALSE, warning=FALSE}

recruitmentInfo <-
  processLimeSurveyDropouts(dat$lastpage,
                            pagenames=c(groupNames,
                                        "Completed"));

ggSave(recruitmentInfo$plots$relativeDropout,
       file = file.path(workingPath, "relative dropout.png"),
       height=6, width=18);

ggSave(recruitmentInfo$plots$absoluteDropout,
       file = file.path(workingPath, "absolute dropout.png"),
       height=6, width=18);

participantRecruitmentOverTime <- 
  ggplot(dat, aes(x=startdate)) +
  geom_histogram(binwidth=60*60*24) +
  scale_x_datetime(date_breaks="1 day") +
  theme_minimal() +
  theme(axis.text.x  = element_text(angle=75, vjust=0));

```

Party Panel participants were recruited primarily through social media. The Dutch Celebrate Safe campaign (see <http://celebratesafe.nl>), Unity (see <http://unity.nl>), as well as related organisations such as event organisers that were partnered with Celebrate Safe promoted Party Panel through Facebook and Twitter posts. In addition, visitors to the Unity website were shown a div pop-up.

This figure shows participant recruitment over time:

```{r participant-recruitment-over-time, results='asis', message=FALSE, warning=FALSE}

knitFig(plotToDraw=participantRecruitmentOverTime,
        figWidth = min(1.5*c(defaultFigWidth, maxFigWidth)),
        figHeight = min(c(defaultFigHeight, maxFigHeight)),
        figCaption = "Participants starting the survey at different dates.");

#   print(suppressWarnings(recruitmentInfo$plots$temporalProgression));

```

During this time, `r nrow(dat);` participants opened the first page containing the Informed Consent. From this point, the progression through the survey was as follows:

```{r progression-through-survey, results="asis", message=FALSE, warning=FALSE}

  knitFig(plotToDraw = recruitmentInfo$plots$relativeDropout,
          figWidth = min(c(2*defaultFigWidth, maxFigWidth)),
          figHeight = min(c(1.5*defaultFigHeight, maxFigHeight)),
          figCaption = "Dropout throughout the questionnaire.");

  pander(recruitmentInfo$progressiveDropout);

```

Of the `r sum(!is.na(dat$informedConsent));` participants answering the Informed Consent, `r sum(dat$informedConsent == "Nee, ik wil toch niet meedoen.", na.rm=TRUE);` participants answered negatively. Of these, `r length(as.character(na.omit(dat$noConsentReason)))` provided a reason. Specifically, the reasons provided were `r vecTxt(as.character(na.omit(dat$noConsentReason)), useQuote='"');`.

`r waveSpecificRandomNumberStatement`

```{r recruitment-devices, results='asis', message=FALSE, warning=FALSE}

if ('screenWidth' %in% names(dat) ||
    'mobile' %in% names(dat) ||
    'userAgent' %in% names(dat)) {

  cat0("\n\n### Devices\n\n");

  if ('mobile' %in% names(dat)) {
    cat0("\n\n#### Device type\n\n");
    kable(userfriendlyscience::freq(dat$mobile)$dat);
  }
  
  if ('screenWidth' %in% names(dat)) {
    cat0("\n\n#### Screen width\n\n");
    screenWidthPowerHist <-
      powerHist(dat$screenWidth,
                xLabel = "Screen width")$plot;
    knitFig(plotToDraw = screenWidthPowerHist,
            figWidth = defaultFigWidth,
            figHeight = defaultFigHeight,
            figCaption = "Histogram for screen width distribution.");
  }

  if ('userAgent' %in% names(dat)) {
    cat0("\n\n#### User agent\n\n");
    dat$userAgent_clean <-
      case_when(grepl("Android", dat$userAgent, fixed=TRUE) ~ "Android",
                grepl("Max OS X", dat$userAgent, fixed=TRUE) ~ "Apple",
                grepl("iPhone", dat$userAgent, fixed=TRUE) ~ "iPhone",
                grepl("Windows Phone", dat$userAgent, fixed=TRUE) ~ "Windows Phone",
                TRUE ~ "Other");
    kable(userfriendlyscience::freq(dat$userAgent_clean)$dat);
  }
  
}

```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

## Participants (sample description)

```{r sample-description, results='asis', message=FALSE, warning=FALSE}

########################################################################
### Gender
########################################################################

pandoc.header("Gender", 3);

genderPie <- ggPie(dat$gender);

knitFig(plotToDraw = genderPie,
        figWidth = defaultFigWidth,
        figHeight = defaultFigHeight,
        figCaption = "Pie chart for gender.");

genderBar <- ggEasyBar(dat[!is.na(dat$gender), 'gender', drop=FALSE]);

knitFig(plotToDraw = genderBar,
        figWidth = min(c(2*defaultFigWidth, maxFigWidth)),
        figHeight = defaultFigHeight,
        figCaption = "Bar chart for gender.");

kable(userfriendlyscience::freq(dat$gender)$dat);

ggSave(plot = genderBar,
       file = file.path(workingPath, "gender (bar).png"),
       height=4, width=18);

########################################################################
### Age
########################################################################

cat("\n\n### Age\n\n");

agePowerHist <- powerHist(dat$age,
                          xLabel = "Age")$plot + xlim(0, 80);
ageDescr <- userfriendlyscience::descr(round(dat$age));

pander(ageDescr);

knitFig(plotToDraw = agePowerHist,
        figWidth = defaultFigWidth,
        figHeight = defaultFigHeight,
        figCaption = "Histogram for age distribution.");

ggSave(plot = agePowerHist,
       file = file.path(workingPath, "age (hist).png"),
       height=4, width=18);

freqMeansDiamondPlots <- list();
freqRidgelinePlots <- list();

for (currentFreqVar in names(frequencyVarNames)) {
  
  cat0("\n\n### ", currentFreqVar, "\n\n");
  
  if (length(frequencyVarNames[[currentFreqVar]]) == 0) {
    stop("No variables matching regex '", currentFreqVar, "'.");
  } else if (all(unlist(frequencyVarNames[[currentFreqVar]]) %in% names(dat))) {
    
    ### Diamond plots
    freqMeansDiamondPlots[[currentFreqVar]] <-
      meansDiamondPlot(dat,
                       items=unlist(frequencyVarNames[[currentFreqVar]]));

    freqRidgelinePlots[[currentFreqVar]] <-
      ggEasyRidge(dat,
                  items=frequencyVarNames[[currentFreqVar]],
                  xlab='frequency (times in the last half year)') +
      scale_x_continuous(sec.axis=dup_axis(breaks=c(6, 26, 182.5),
                                           labels=c("maand", "week", "dag")));

    pandoc.header("Diamond and ridgeline plots", 4);
    
    knitFig(plotToDraw = freqMeansDiamondPlots[[currentFreqVar]],
            figWidth = min(c(2*defaultFigWidth, maxFigWidth)),
            figHeight = defaultFigHeight,
            figCaption = paste0("Diamond plot for ", currentFreqVar, "."));
    
    ggSave(plot = freqMeansDiamondPlots[[currentFreqVar]],
           file = file.path(workingPath, paste0(currentFreqVar, "-(diamond).png")),
           height=2.54 * defaultFigHeight, width=2 * 2.54 * defaultFigWidth);
    
    knitFig(plotToDraw = freqRidgelinePlots[[currentFreqVar]],
            figWidth = min(c(2*defaultFigWidth, maxFigWidth)),
            figHeight = defaultFigHeight,
            figCaption = paste0("Ridgeline plot for ", currentFreqVar, "."));
    
    ggSave(plot = freqRidgelinePlots[[currentFreqVar]],
           file = file.path(workingPath, paste0(currentFreqVar, "-(ridgeline).png")),
           height=2.54 * defaultFigHeight, width=2 * 2.54 * defaultFigWidth);

    cat("\n\n#### Frequencies and easybarplots {.tabset}\n\n");

    cat("\n\n##### Categories\n\n");

    if (length(frequencyCategoryVarNames[[currentFreqVar]]) == 1) {
      print(kable(userfriendlyscience::freq(dat[, frequencyCategoryVarNames[[currentFreqVar]]])$dat));
    } else {
      print(kable(multiVarFreq(dat, items=frequencyCategoryVarNames[[currentFreqVar]],
                               sortByMean=FALSE)));
    }
    
    knitFig(ggEasyBar(dat,
                      items=frequencyCategoryVarNames[[currentFreqVar]],
                      sortByMean=FALSE),
            figWidth = min(c(2*defaultFigWidth, maxFigWidth)),
            figHeight = defaultFigHeight,
            figCaption = paste0("EasyBar plot for ", currentFreqVar, "."));
    
    cat("\n\n##### Raw\n\n");

    if (length(frequencyVarNames[[currentFreqVar]]) == 1) {
      print(kable(userfriendlyscience::freq(dat[, frequencyVarNames[[currentFreqVar]]])$dat));
    } else {
      print(kable(multiVarFreq(dat, items=frequencyVarNames[[currentFreqVar]],
                               sortByMean=FALSE)));
    }
    
    knitFig(ggEasyBar(dat,
                      items=frequencyVarNames[[currentFreqVar]],
                      sortByMean=FALSE),
            figWidth = min(c(2*defaultFigWidth, maxFigWidth)),
            figHeight = defaultFigHeight,
            figCaption = paste0("EasyBar plot for ", currentFreqVar, "."));

  } else {
    stop("Not all variables matching regex '", currentFreqVar, "' exist in dataframe.");
  }
}

########################################################################
### Sexual preference
########################################################################

if ('sexualPreference' %in% names(dat)) {
  cat("\n\n### Sexual preference\n\n");
  kable(userfriendlyscience::freq(dat$sexualPreference)$dat);
}

########################################################################
### Geographical distribution
########################################################################

### Merge data with postcode latitude and longitude
dat <- merge(x=dat, y=pcDat, by='postcode', all.x=TRUE);

### Build temporary dataframe for mapping the numbers of participants
tmpDat <- ddply(dat[, c('postcode', 'lat', 'lon')], .(postcode), function(dat) {
  return(data.frame(n=nrow(dat),
                    lat=mean(dat$lat, na.rm=TRUE),
                    lon=mean(dat$lon, na.rm=TRUE)));
});

### Remove people who didn't answer or didn't get to this question
tmpDat <- tmpDat[!is.na(tmpDat$lat), ];

### Get map of the Netherlands from Google Maps (skip if there's no
### internet)
if (require('RCurl')) {
  if (url.exists('partypanel.nl')) {
    if (!exists('netherlands')) {
      netherlands <<- get_map(location = c(lon = 5.2507557, lat = 52.1680345),
                              color = "color",
                              source = "google",
                              maptype = "roadmap",
                              zoom = 7);
    }

    ### Map the resulting locations to the map as circles.
    participantOriginsEmpty <- ggmap(netherlands,
                                     extent='device',
                                     darken=c(0, "#172f47"));

    participantOrigins <- participantOriginsEmpty +
      geom_point(data=tmpDat,
                 aes(x=lon, y=lat, size=n),
                 color='red', alpha=.5, stroke=1) +
      scale_size(range=c(5, 40)) +
      theme(legend.position="none")
    
    ggSave(plot=participantOrigins,
       file.path(workingPath,
                 paste0("partypanel-", waveNumber, "-geography.svg")),
       width=20,
       height=20,
       bg = "transparent");

    knitFig(plotToDraw = participantOrigins,
            figWidth = 16,
            figHeight = 16,
            figCaption = paste("Geographical distribution of Party Panel participants"));
    
  }
}

```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

## Behavioral determinants {.tabset}

This section is quite full, and is therefore again organised using tabs. The first tab ("CIBER plots and how to read them") contains an introduction to and explanation of the data visualisation used to explore determinant importance. The second tab ("Determinant structures") shows the theoretical determinant structure that these determinant importance analyses are based on. The third tab ("Determinant importance"), finally, shows the CIBER plots for the determinants measured in this Party Panel wave.

### CIBER plots and how to read them

When thinking about which determinants and sub-determinants to target in a behavior change intervention, it is important to consider both the univariate distributions (i.e. means) and the associations to behavior and determinants of behavior (such as intention or other theoretically relevant determinants; Peters, 2012). Usually, means and correlation coefficients are used to inspect these, but it is important to realise that sample estimates are subject to random variability, and therefore, will be different in different samples. Instead of using point estimates, therefore, it is better to use confidence intervals (Crutzen, Peters &  Noijen, 2017).

Confidence Interval Based Estimation of Relevance plots (CIBER plots) facilitate inspection of many data points and confidence intervals simultaneously (Crutzen, Peters &  Noijen, 2017). Because CIBER plots are a relatively new development, we will briefly explain how to read them here using simulated data.

In this fictional example, we measured the determinants of doing a determinant study when developing an intervention. In this example, we measured three sub-determinants of attitude (called beliefs):

```{r CIBERplot-explanation, results='asis', message=FALSE, warning=FALSE}

exampleData <- simDataSet(200,
                          c('firstBelief',
                            'secondBelief',
                            'thirdBelief',
                            'attitude',
                            'intention'),
                          correlations=c(-.3, .3),
                          specifiedCorrelations=list(c('firstBelief',
                                                       'attitude',
                                                       .42),
                                                     c('thirdBelief',
                                                       'attitude',
                                                       .57),
                                                     c('firstBelief',
                                                       'intention',
                                                       .39),
                                                     c('thirdBelief',
                                                       'intention',
                                                       .53)),
                          means=c(4,   ### First belief
                                  2,     ### Second belief
                                  6,   ### Third belief
                                  4,     ### Attitude
                                  4),  ### Intention
                          range=c(1,7),
                          seed=19811027,
                          empirical=FALSE,
                          silent=TRUE);

### Skew second belief to the right
exampleData$secondBelief <- log(exampleData$secondBelief, 2);

### Round numbers
exampleData <- round(exampleData);

### Correct for values that are too high or too low
exampleData[exampleData<1] <- 1;
exampleData[exampleData>7] <- 7;

exampleCIBER <- 
  behaviorchange::CIBER(exampleData,
                        determinants=c('firstBelief',
                                       'secondBelief',
                                       'thirdBelief'),
                        subQuestions=c('A determinant study provides ...\ninsight into why people\nexhibit the target behavior.',
                                       'The effect of an intervention ...\non whether the right\ndeterminants are targeted.',
                                       'Interventions that are based on\ndeterminant studies are, because of that, ...'),
                        leftAnchors=c("Absolutely\nno",
                                      "Does not\ndepend",
                                      "Less\neffective"),
                        rightAnchors=c("A lot\nof",
                                       "Depends\na lot",
                                       "More\neffective"),,
                        targets=c('attitude', 'intention'),
                        drawPlot = FALSE);

knitFig(plotToDraw = 'exampleCIBER',
        template = pp_knitFig_determinantTemplate,
        figWidth = attr(exampleCIBER, 'width'),
        figHeight = attr(exampleCIBER, 'height') + .5,
        figCaption = "A fictional example of a CIBER plot.",
        drawPlot = TRUE,
        headerName = "CIBER plot example",
        headerLevel = 4);

```

##### Explaining the plot title

The title doubles as a legend: each higher-level determinant (called a 'target' in CIBER plots) is designated a color that is used in the plot. In this case, attitude is red and intention is blue. These colors are used in the right-hand panel of the plot (see below).

The title also shows the confidence interval (by default the 95% confidence interval) for the proportion of explained variance (or <sup>2</sup> for each target as explained by the (sub-) determinants in the plot (in this case, by the three beliefs).

##### Explaining the left-hand panel

The left-hand panel in a CIBER plot shows the univariate distributions of each (sub-)determinant, in these case the three beliefs. It shows both the individual participants' scores as well as the confidence interval for the mean as diamonds (by default, CIBER plots show 99.99% confidence intervals). The diamons are colored as a function of the relative position of the mean:

- if participants mostly score towards the bottom of the scale (a low mean), the diamonds are red;
- if participants mostly score around the middle, or if they score all over the place (in both cases the mean is in the middle), the diamonds are blue; and
- if participants score towards the top of the scale (a high mean), the diamonds are green.

Note that in this fictional example, it's quite clear that the data were simulated: usually, participants don't all score so closely to the mean.

##### Explaining the right-hand panel

The right-hand panel in a CIBER plot shows the associations to the higher-order determinants, in this case attitude and intention (of course, you could also plot associations to behavior here). In this panel, individual scores are not shown, only the diamonds representing the confidence intervals for the correlation coefficicients (by default, 95% confidence intervals).

The strokes (borders) of these diamonds indicate which target each diamond represents. In this example, the red diamonds represent the beliefs' associations with attitude, and the blue diamonds represent the beliefs' associations with intention (see the section on the plot title, above).

The fill (inside color) of these diamonds is also a function of how strong the association is:

- diamonds representing very strong negative associations (correlations approaching -1) are filled with a red color;
- diamonds representing no association (correlations around 0) are filled with a grey color; and
- diamonds representing very strong associations (correlations approaching 1) are filled with a green color.

#### Interpretation of this CIBER plot

In this fictional sample, the responses to the first belief show that participants do not strongly believe that a determinant study provides a lot of insight into why people exhibit the target behavior. This belief is quite strongly related to attitude and intention, and therefore this seems a viable intervention target. If this were a real scenario, and we would want to promote the use of determinant studies, succesfully changing this belief would likely contribute to behavior change.

The second belief is held by even fewer people: these fictional participants believe that the effect of an intervention does not depend on whether the right determinants are targeted. Interestingly, the right-hand panel shows that this belief is not strongly associated to attitude and intention. It is possible that this is a consequence of the skewed distribution: almost all participants score 1 or 2, which means that there is very little variation, which means that the correlation cannot achieve a very high value. However, if we assume for the moment that the weak association of this belief to attitude and intention is not a statistical artifact, we would conclude that changing this belief would be unlikely to contribute to behavior change.

The third belief is already held by most participants: the mean is between 5 and 6 in a 7-point scale, so most people believe that interventions that are based on determinant studies are more effective because they are (this is an unrealistic contrast with the second belief; these *are* simulated data, after all). This belief was also quite strongly associated to attitude and behavior. Since most people already hold this belief to some degree, an intervention would focus on people who answered in the middle of the scale (i.e. who think that it doesn't matter much for effectiveness whether an intervention is based on a determinant study).

### Determinant structures

These are visualisations of the determinant structures of the behaviors in this Party Panel wave. The associations of the sub-determinants in each of these determinants with the overarching determinants and with intention will then be visualised using CIBER plots.

```{r ciber-plot-generation, screenshot.force=TRUE, message=FALSE, warning=FALSE}

###############################################################################
### For each behavior, process the determinant structure to add CIBER plots
###############################################################################

for (currentDetStruct in detStruct) {

  ### Add determinant importance plots
  behaviorchange::detStructCIBER(currentDetStruct,
                                 data=dat);
} 

### screenshot.force = TRUE

# for (i in seq_along(detStruct)) {
  # cat("\n\n");
  # pandoc.header(detStruct[[i]]$name, level=4);
  # cat("\n\n");

  # chunkName <- digest(Sys.time());
  # figCaption <- paste0("Determinant structure for ",
  #                      detStruct[[i]]$name);
  # 
  # cat(figCaption);
  # cat("\n\n");
  # 
  # plot(detStruct[[i]]);

  # knit(text = knit_expand(text = paste0("\n\n```{r {{chunkName}}, fig.height={{figHeight}}, fig.width={{figWidth}}, fig.cap='{{figCaption}}', echo=FALSE, cache=FALSE, message=FALSE }\n   data.tree:::plot.Node(detStruct[[", i, "]]);\n```\n\n"),
  #                             chunkName = chunkName,
  #                             figWidth = 10,
  #                             figHeight = 10,
  #                             figCaption = figCaption),
  #          quiet = TRUE);

  ### We have to directly call this, because otherwise
  ### the 'determinantStructure' method is dispatched.
  # xGraph <-
  #   ToDiagrammeRGraph(detStruct[[i]],
  #                     direction='climb',
  #                     pruneFun=NULL);
  # xGraph <- add_global_graph_attrs(xGraph,
  #                                  "layout",
  #                                  "dot",
  #                                  "graph");
  # xGraph <- add_global_graph_attrs(xGraph,
  #                                  "rankdir",
  #                                  "RL",
  #                                  "graph");
  # render_graph(xGraph, output='graph');
  #data.tree:::plot.Node(detStruct[[i]]);
  # cat("\n\n");
# }

```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

```{r wave-specific-determinant-structures, results="asis", child=file.path(scriptPath, paste0("partypanel-", waveNumber, "-wave-specific-determinant-structures.Rmd"))}
```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

### Determinant importance

This section contains CIBER plots to show the determinant relevance. These are organised based on the determinant structure; the headings and each figure's caption shows to which behavior and to which (sub)-determinants each CIBER plot pertains.

```{r determinant-importance, results='asis', message=FALSE, warning=FALSE}

singleQuestionEasyBarList <<- list();
determinantDetStructList <<- list();

for (i in seq_along(detStruct)) {
  detStruct[[i]]$Do(function(currentNode) {
    
    ### If we have lower level determinants, generate a ciberplot here
    if ((!is.null(currentNode$scaleVarName)) &&
        (length(Get(currentNode$children, 'scaleVarName')) > 0) &&
        all(Get(currentNode$children, 'scaleVarName') %in% names(dat))) {
      
        sampleSize <-
          sum(complete.cases(dat[, c(Get(currentNode$children,
                                         'scaleVarName'),
                                     currentNode$scaleVarName)]));
      
        tmpCIBER <- 
          behaviorchange::CIBER(data=dat,
                                determinants=Get(currentNode$children, 'scaleVarName'),
                                fullColorRange=c(1, 7),
                                targets=currentNode$scaleVarName,
                                xbreaks=1:7,
                                drawPlot=FALSE);
        figHeight <- 2.5 + attr(tmpCIBER, 'height');
        figWidth <- attr(tmpCIBER, 'width');
        drawPlot <- TRUE;
        determinantDetStructList[[length(determinantDetStructList)+1]] <<-
          arrangeGrob(ggEasyRidge(dat,
                                  currentNode$scaleVarName,
                                  labels="") +
                        scale_x_continuous(breaks=1:7) +
                        coord_cartesian(xlim=c(1, 7)),
                       meansDiamondPlot(dat,
                                        currentNode$scaleVarName,
                                        xbreaks=1:7,
                                        labels="") +
                        coord_cartesian(xlim=c(1, 7)),
                      tmpCIBER,
                      ncol=1);
        plotToDraw <- paste0("determinantDetStructList[[",
                             length(determinantDetStructList),
                             "]]");
        plotToDrawAsPlot <- determinantDetStructList[[length(determinantDetStructList)]];
    } else if (is.null(currentNode$determinantImportance)) {
      if (is.null(currentNode$scaleVarName)) {
        figHeight <- figWidth <- 1;
        drawPlot <- FALSE;
        plotToDraw <- "";
        sampleSize <- NA;
      } else {
        figHeight <- 2.5;
        figWidth <- 8;
        drawPlot <- TRUE;
        sampleSize <- sum(!is.na(dat[, currentNode$scaleVarName]));
        ### Bit messy; but store plot in parent environment for
        ### inclusion by knitr
        singleQuestionEasyBarList[[length(singleQuestionEasyBarList)+1]]  <<- 
          arrangeGrob(ggEasyRidge(dat,
                                  currentNode$scaleVarName,
                                  labels="") +
                        scale_x_continuous(breaks=1:7) +
                        coord_cartesian(xlim=c(1, 7)),
            # singleQuestionEasyBar(currentNode$scaleVarName,
            #                                 knitFig=FALSE),
                      meansDiamondPlot(dat,
                                       currentNode$scaleVarName,
                                       xbreaks=1:7,
                                       labels="") +
                        coord_cartesian(xlim=c(1, 7)),
                      ncol=1);
        plotToDraw <- paste0("singleQuestionEasyBarList[[",
                             length(singleQuestionEasyBarList),
                             "]]");
        plotToDrawAsPlot <- singleQuestionEasyBarList[[length(singleQuestionEasyBarList)]];
      }
    } else {
      figHeight <- attr(currentNode$determinantImportance, 'height');
      figWidth <- attr(currentNode$determinantImportance, 'width');
      drawPlot <- TRUE;
      sampleSize <- sum(complete.cases(dat[, unlist(currentNode$varNames)]));
      plotToDraw <- paste0("detStruct[[", i, "]]$",
                           vecTxt(currentNode$path[-1],
                                  delimiter="$",
                                  lastElements=0,
                                  useQuote="`"),
                           "$determinantImportance");
      plotToDrawAsPlot <- currentNode$determinantImportance;
    }
    chunkName <- gsub("\\s", "", paste0(paste0(currentNode$path, collapse="-")));
    headerName <- currentNode$name;
    headerLevel <- currentNode$level + 3;
    figCaption <- toTitleCase(paste0(paste0(currentNode$path, collapse=" - ")));

    ### Feed to knitr for report
    if (exists('sampleSize') &&
        !is.null(sampleSize) &&
        !is.na(sampleSize)) {
      knitFig(plotToDraw = plotToDraw,
              template = pp_knitFig_determinantTemplate_sampleSize,
              figWidth = figWidth,
              figHeight = figHeight,
              figCaption = figCaption,
              drawPlot = drawPlot,
              chunkName = chunkName,
              headerName = toTitleCase(headerName),
              headerLevel = headerLevel,
              sampleSize = sampleSize);
    } else {
      knitFig(plotToDraw = plotToDraw,
              template = pp_knitFig_determinantTemplate,
              figWidth = figWidth,
              figHeight = figHeight,
              figCaption = figCaption,
              drawPlot = drawPlot,
              chunkName = chunkName,
              headerName = toTitleCase(headerName),
              headerLevel = headerLevel);
    }
    # 
    # cat0("\n\n",
    #     repStr("#", headerLevel+1),
    #     " Raw data {.tabset}",
    #     "\n\n",
    #     repStr("#", headerLevel+2),
    #     " Overview\n\n",
    #     "Click the tabs to the right for the raw data.\n\n");
    # 
    # cat0("\n\n",
    #     repStr("#", headerLevel+2),
    #     " Raw frequencies\n\n");
    # 
    # tmpMultiVarFreq <- multiVarFreq(dat, unlist(currentNode$varNames));
    # 
    # pander(tmpMultiVarFreq);
    # 
    # cat0("\n\n",
    #     repStr("#", headerLevel+2),
    #     " Percentages\n\n");
    # 
    # pander(apply(tmpMultiVarFreq,
    #              2,
    #              function(x)
    #                return(x/rowSums(tmpMultiVarFreq,
    #                                 na.rm=TRUE))
    #              )
    #        );
    # 
    # cat("\n\n");
    # 
    #if (!is.null(currentNode$determinantImportance)) {
    if (drawPlot) {
      ### Save to disk for other uses
      ggSave(plot=plotToDrawAsPlot, #currentNode$determinantImportance,
             file.path(workingPath,
                       paste0("CIBER-",
                              paste0(paste0(currentNode$path, collapse="-")),
                              ".png")),
             width=figWidth,
             height=figHeight,
             dpi = 600,
             bg = "transparent");
    }
  });
}


cat("\n\n");


```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

## Wave specific analyses

```{r generic-wave-specific-analyses, results="asis", message=FALSE, warning=FALSE}

for (currentVar in names(waveSpecificVariableList)) {
  
  ### Print header
  pandoc.header(currentVar, level=3);
  
  ### Get variable name(s)
  tryCatch({
    currentVarNameList <- grep(waveSpecificVariableList[[currentVar]]$regex,
                               names(dat),
                               value=TRUE,
                               perl=TRUE);
  }, error = function(e) {
    cat0("This entry in the list of wave specific variables had a regular expression that caused an error. The error is:\n\n",
         e$message, "\n\n");
    cat0("To troubleshoot, see `waveSpecificVarnameRegExPairs` in 'partypanel-", waveNumber, "-wave-specific-preparation.Rmd'.\n");
    currentVarNameList <- c();
  });
      
  plotWidthMultiplier <- ifelse(is.null(waveSpecificVariableList[[currentVar]]$plotWidthMultiplier),
                                1, waveSpecificVariableList[[currentVar]]$plotWidthMultiplier);
  plotHeightMultiplier <- ifelse(is.null(waveSpecificVariableList[[currentVar]]$plotHeightMultiplier),
                                 1, waveSpecificVariableList[[currentVar]]$plotHeightMultiplier);
  
  currentCaption <- NULL;
  currentPlots <- list();
  currentHasAnchors <- FALSE;
  currentHeightOverride <- FALSE;
  
  if (length(currentVarNameList) > 0) {
    if (length(currentVarNameList) == 1) {

      ### Show variable names and caption
      if (is.null(waveSpecificVariableList[[currentVar]]$caption)) {
        if (!is.null(labelDf[labelDf$varNames.cln %in% currentVarNameList, ])) {
          currentCaption <-  labelDf[labelDf$varNames.cln %in% currentVarNameList, ];
        }
      } else {
        currentCaption <- waveSpecificVariableList[[currentVar]]$caption;
      }
      pandoc.p(paste0(currentCaption, " ('", currentVarNameList, "')"));
      
      varVector <- dat[, currentVarNameList];
      
      ### Recode if necessary
      if (!is.null(waveSpecificVariableList[[currentVar]]$recode)) {
        varVector <- factor(car::Recode(varVector, waveSpecificVariableList[[currentVar]]$recode));
      }
      
      if (!is.null(waveSpecificVariableList[[currentVar]]$showTotalValid) &&
          waveSpecificVariableList[[currentVar]]$showTotalValid) {
        pandoc.p(paste0("Total number of valid (nonmissing) responses: ", sum(!is.na(varVector))));
      }

      if ((waveSpecificVariableList[[currentVar]]$type == "dichotomous") &&
          !is.null(waveSpecificVariableList[[currentVar]]$showPropPlot) &&
          waveSpecificVariableList[[currentVar]]$showPropPlot) {
        currentPlots[[length(currentPlots) + 1]] <-
          ggProportionPlot(varVector[!is.na(varVector)],
                           subQuestions=currentVarNameList);
      }
      
      if (!is.null(waveSpecificVariableList[[currentVar]]$showFreq)
            && waveSpecificVariableList[[currentVar]]$showFreq) {
        cat("\n\n");
        cat(kable(userfriendlyscience::freq(varVector)$dat),
            sep="\n");
        cat("\n\n");
      }
      
      if (waveSpecificVariableList[[currentVar]]$type == "open") {
        cat("\n**Responses:**",
            vecTxtQ(varVector[nchar(varVector, keepNA=FALSE) > 2]),
            "\n\n");
      }

    } else {

      ### Multiple variables provided in this set
      
      ### Show variable names and caption
      if (is.null(waveSpecificVariableList[[currentVar]]$caption)) {
        if (!is.null(labelDf[labelDf$varNames.cln %in% grep("^epPossessionType_(.*)", names(dat), value=TRUE), ])) {
          currentCaption <- vecTxtQ(labelDf[labelDf$varNames.cln %in% currentVarNameList, ]);
        }
      } else {
        currentCaption <- waveSpecificVariableList[[currentVar]]$caption;
      }
      pandoc.p(paste0(ifelse(is.null(currentCaption), "(", paste0(currentCaption, " (")),
                      vecTxtQ(currentVarNameList), ")"));
      
      if (nrow(labelDf[labelDf$varNames.cln %in% currentVarNameList, ]) > 0) {
        currentLabelDf <- labelDf[labelDf$varNames.cln %in% currentVarNameList, ];
        currentLeftAnchors <- currentLabelDf$leftAnchors;
        currentRightAnchors <- currentLabelDf$rightAnchors;
        currentSubQuestions <- currentLabelDf$subQuestions;
        if ((max(nchar(currentLeftAnchors)) > 2) &&
            (max(nchar(currentRightAnchors)) > 2)) {
          currentHasAnchors <- TRUE;
        }
      } else {
        currentSubQuestions <- NA;
      }

      ### Multiple response question
      if (waveSpecificVariableList[[currentVar]]$type == 'multi') {
        if (!is.null(waveSpecificVariableList[[currentVar]]$showFreq)
            && waveSpecificVariableList[[currentVar]]$showFreq) {
          cat0("\n\n");
          multiResponseResult <-
            multiResponse(dat, regex=waveSpecificVariableList[[currentVar]]$regex);
          if (!any(is.null(currentSubQuestions)) && !any(is.na(currentSubQuestions))) {
            multiResponseResult$Option <- c(currentSubQuestions, "Total");
          }
          pander(multiResponseResult);
          cat0("\n\n");
        }
      } else if (waveSpecificVariableList[[currentVar]]$type == "array") {

        currentCleanLabels <-
          labelDf$varLabels.cln[labelDf$varNames.cln %in% currentVarNameList];

        ### Set pretty labels
        currentVarLabels <-
          ifelseObj(is.null(waveSpecificVariableList[[currentVar]]$labels),
                    ifelseObj(is.na(currentSubQuestions),
                              NULL,
                              currentSubQuestions),
                    waveSpecificVariableList[[currentVar]]$labels);
        if (anyDuplicated(currentVarLabels) > 0) {
          currentVarLabels <- NULL;
        }

        if (!is.null(waveSpecificVariableList[[currentVar]]$showFreq)
            && waveSpecificVariableList[[currentVar]]$showFreq) {
          cat("\n\n");
          pander(multiVarFreq(dat,
                              items=currentVarNameList,
                              labels = currentVarLabels));
          cat("\n\n");
        }
        
        ### Bar plot
        if (!is.null(waveSpecificVariableList[[currentVar]]$showBarPlot)
            && waveSpecificVariableList[[currentVar]]$showBarPlot) {
          ### Remove character vectors
          characterVectors <- unlist(lapply(dat[, currentVarNameList], is.character));
          if (any(characterVectors)) {
            currentVarNameList <- currentVarNameList[!characterVectors];
          }
          currentPlots[[length(currentPlots) + 1]] <-
            ggEasyBar(dat,
                      items=currentVarNameList,
                      labels = currentVarLabels);
        }
        
        ### Diamond plot
        if (!is.null(waveSpecificVariableList[[currentVar]]$showDiamondPlot)
            && waveSpecificVariableList[[currentVar]]$showDiamondPlot) {
          
          ### Remove character vectors
          characterVectors <- unlist(lapply(dat[, currentVarNameList], is.character));
          if (any(characterVectors)) {
            currentVarNameList <- currentVarNameList[!characterVectors];
          }
          
          if (currentHasAnchors) {
            currentPlots[[length(currentPlots) + 1]] <-
              biAxisDiamondPlot(dat, items=currentVarNameList,
                                leftAnchors = currentLeftAnchors,
                                rightAnchors = currentRightAnchors,
                                subQuestions = currentSubQuestions,
                                decreasing=FALSE,
                                drawPlot=FALSE);
            currentHeightOverride <-
              ((1 + 1.25 * max(length(currentSubQuestions), 1.5)) / 2.54);
          } else {
            currentPlots[[length(currentPlots) + 1]] <-
              meansDiamondPlot(dat, items=currentVarNameList,
                               labels = currentVarLabels,
                               decreasing=FALSE);
          }
        }

        ### Ridgeline plot
        if (!is.null(waveSpecificVariableList[[currentVar]]$showRidgelinePlot)
            && waveSpecificVariableList[[currentVar]]$showRidgelinePlot) {
          ### Remove character vectors
          characterVectors <- unlist(lapply(dat[, currentVarNameList], is.character));
          if (any(characterVectors)) {
            currentVarNameList <- currentVarNameList[!characterVectors];
          }
          currentPlots[[length(currentPlots) + 1]] <-
            ggEasyRidge(dat,
                        items=currentVarNameList,
                        labels = currentVarLabels);
        }
        
        ### Associations
        if (!is.null(waveSpecificVariableList[[currentVar]]$assoc)
            && (waveSpecificVariableList[[currentVar]]$assoc != FALSE) &&
            length(waveSpecificVariableList[[currentVar]]$assoc > 0)) {
          ### Remove character vectors
          characterVectors <- unlist(lapply(dat[, currentVarNameList], is.character));
          if (any(characterVectors)) {
            currentVarNameList <- currentVarNameList[!characterVectors];
          }
          if (isTRUE(waveSpecificVariableList[[currentVar]]$assoc)) {
            ### Show associations with all determinants
            for (currentBehaviorIndex in seq_along(detStruct)) {
              cat0("Here association with ", names(detStruct[[currentBehaviorIndex]]));
            }
          } else {
            ### These are regular expressions; only show associations
            ### with those variables
            for (currentAssocVarRegex in waveSpecificVariableList[[currentVar]]$assoc) {
              assocVarList <- grep(currentAssocVarRegex, names(dat), value=TRUE);
              currentPlots[[length(currentPlots) + 1]] <-
                userfriendlyscience::associationsDiamondPlot(dat,
                                                             covariates=currentVarNameList,
                                                             criteria=assocVarList,
                                                             labels = currentVarLabels);
            }
          }
        }

      }

    } ### End of if more than one variable in this set

    # ## For debugging
    # message(paste0("\n\n",
    #                currentVar,
    #                "\n\n",
    #                class(currentPlots[[1]]),
    #                "\n\n"));

    ### Show the plot(s)
    if (length(currentPlots) > 0) {
      if (!is.null(waveSpecificVariableList[[currentVar]]$combinePlots) &&
          waveSpecificVariableList[[currentVar]]$combinePlots) {
        if (length(currentPlots) == 1) {
          currentPlotToDraw <- currentPlots;
        } else {
          currentPlotCols <- 2;
          currentPlotRows <- ceiling(length(currentPlots) / 2);
          currentFigWidth <- min(c(plotWidthMultiplier*currentPlotCols*defaultFigWidth, maxFigWidth));
          currentFigHeight <- min(c(plotHeightMultiplier*currentPlotRows*defaultFigHeight, maxFigHeight));
          currentPlotToDraw <- arrangeGrob(grobs = currentPlots, ncol=currentPlotCols);
        }
        knitFig(plotToDraw = currentPlotToDraw,
                figWidth = currentFigWidth,
                figHeight = currentFigHeight,
                figCaption = paste("Visualisation for", currentVar));
      } else {
        for (plotIndex in seq_along(currentPlots)) {
          knitFig(plotToDraw = currentPlots[[plotIndex]],
                  figWidth = min(c(plotWidthMultiplier*defaultFigWidth, maxFigWidth)),
                  figHeight = ifelse(is.numeric(currentHeightOverride),
                                     currentHeightOverride,
                                     min(c(plotHeightMultiplier*defaultFigHeight, maxFigHeight))),
                  figCaption = ifelse(length(currentPlots) > 1,
                                      paste("Visualisation", plotIndex,
                                            "of", length(currentPlots),
                                            "for", currentVar),
                                      paste("Visualisation for", currentVar)));
        }
      }
    }
    
  } else {
    cat0("This entry in the list of wave specific variables had a regular expression without matches. For diagnostic purposes, here is the entire entry:\n\n");
    cat0("```\n", paste0(capture.output(str(waveSpecificVariableList[[currentVar]])), collapse="\n"), "\n```\n\n");
    cat0("This is usually either caused by a typo or because a variable was renamed (see `waveSpecificVarnameRegExPairs`).");
  }
}

```

```{r wave-specific-analyses, results="asis", child=file.path(scriptPath, paste0("partypanel-", waveNumber, "-wave-specific-analyses.Rmd"))}
```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

## Input for infographic

We aim to have an infographic made for each Party Panel wave, to present some of the most important findings to the participants and members of the general public. This tab contains the information sent to the designer for each infographic.

```{r generic-infographic, message=FALSE, warning=FALSE, results="asis"}

pandoc.header("Age and gender", level=3);

pandoc.header("Age", level=4);

pander(ageDescr);

pandoc.p(paste("The mode of age (i.e. the most common age) is ",
               vecTxt(modus(round(dat$age))),
               "year old."));

pandoc.header("Gender", level=4);

kable(userfriendlyscience::freq(dat$gender)$dat);

pandoc.header("Education level", level=3);

kable(userfriendlyscience::freq(dat$education)$dat);

if (exists('participantOrigins') && !is.null(participantOrigins)) {
  pandoc.header("Geographical distribution", level=3);
  knitFig(plotToDraw = participantOrigins,
          figWidth = 16,
          figHeight = 16,
          figCaption = paste("Geographical distribution of Party Panel participants"));
}

pandoc.header("Nightlife attendance", level=3);

pander(multiVarFreq(dat, items=frequencyCategoryVarNames$goingOutFreq, sortByMean=FALSE));

```

```{r wave-specific-infographic, results="asis", child=file.path(scriptPath, paste0("partypanel-", waveNumber, "-wave-specific-infographic.Rmd"))}
```

<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->
<!--------------------------------------------------------------------->

## References

This is a list of literature that is either cited in this Party Panel report, or useful to inspect as background for readers not familiar with behavior change.

Two accessible papers about two important steps in behavior change (*understanding* the behavior and *changing* the behavior) are:

- Peters, G.-J. Y. (2014). [A practical guide to effective behavior change: How to identify what to change in the first place.](https://ehps.net/ehp/index.php/contents/article/download/ehp.v16.i5.p142/7) *European Health Psychologist, 16* (5), 142-155. 

- Kok, G. (2014). [A practical guide to effective behavior change: How to apply theory- and evidence-based behavior change methods in an intervention.](https://ehps.net/ehp/index.php/contents/article/download/ehp.v16.i5.p156/8) *European Health Psychologist, 16* (5), 156–170.

A list of methods for behavior change with their parameters for effectiveness, organised by determinant they can target, is available as supplemental material with the following paper:

- Kok, G., Gottlieb, N. H., Peters, G.-J. Y., Mullen, P. D., Parcel, G. S., Ruiter, R. A. C., … Bartholomew, L. K. (2016). A taxonomy of behavior change methods: an Intervention Mapping approach. Health Psychology Review, 10(3), 297–312. http://doi.org/10.1080/17437199.2015.1077155 (a version of this paper with the tables with method appended is available at https://osf.io/ng3xh)

A paper explaining the plots we use in these reports to show determinant relevance is at:

- Crutzen, R., Peters, G.-J. Y., & Noijen, J. (2017). Using Confidence Interval-Based Estimation of Relevance to select social-cognitive determinants for behaviour change interventions. Frontiers in Public Health, 5(July), 1–9. http://doi.org/10.3389/fpubh.2017.00165

## Appendices

### Detailed logs

#### Data cleaning output

```{r data-cleaning-output, results='asis', message=FALSE, warning=FALSE}
cat(dataCleaningOutput, collapse="\n\n", sep="\n\n");
```

#### Class correction output

```{r class-correction-output, results='asis', message=FALSE, warning=FALSE}
cat("\n\n", classCorrectionOutput, "\n\n");
```

### Codebook (Survey Questions for reference)

```{r codebook, results="asis"}
cat(apply(labelDf, 1, function(x) {
  cat0("* <span style='color:red;'>", x[1], "</span> - ", x[3],
       " - <span style='color:grey'>", x[2], "</span>\n");
}));
```
